#!/usr/bin/python3

# pip install gitpython
import git
import os
import re
from subprocess import call
import configparser

def getNextRelease(strRelease):
    x = re.findall("^(v\d{1,4}\.\d{1,4}\.)(\d{1,4})$", strRelease)
    next = str(int(x[0][1]) + 1)
    return x[0][0] + next

# Main

def main():
    blnVerbose = False

    # Check if current directory is a git repo
    if (os.path.exists(".git") == False):
        print(".git not found.")
        exit(0)

    # Check for Configfile
    if (os.path.exists(".gitrelease") == False):
        print(".gitrelease not found")
        exit(0)

    config = configparser.ConfigParser()
    config.sections()
    config.read('.gitrelease')
    default = config['DEFAULT']

    strVerbose = default.get('verbose', fallback='false')
    strEditor = default.get('editor', fallback='none')
    strFileName = default.get('filename', fallback='none')
    strFileCommitMessage = default.get('file_commit_message', fallback='')
    strCommand = default.get('command', fallback='none')
    strArguments = default.get('arguments', fallback='none')

    if (strVerbose.lower() == 'true'):
        blnVerbose = True

    if strEditor != 'none':
        if (os.path.exists(strFileName) == False):
            print("file " + strFileName + " does not exist")
            exit(0)

    repo = git.Repo(search_parent_directories=True)
    branch = repo.active_branch

    if branch.name == 'develop':
        if blnVerbose:
            print(branch.name)
    else:
        print('no develop branch found')
        exit(0)

    if repo.untracked_files:
        print('develop branch has untracked files')
        exit(0)

    if repo.is_dirty():
        print('develop branch has uncommitted files')
        exit(0)

    tags = sorted(repo.tags, key=lambda t: t.commit.committed_datetime)
    
    strLatestTag = "v0.0.0"
    if len(tags) > 0:
        strLatestTag = str(tags[-1])

    print("Current release: " + strLatestTag)

    strNextRelease = getNextRelease(strLatestTag)

    string = "Give new Release [" + strNextRelease + "]: "
    new_tag = (input(string) or strNextRelease)
    print(new_tag)

    # https://git-flow.readthedocs.io/en/latest/releases.html
    # 
    # git flow release start v1.4.0 or
    # git checkout -b release/v0.0.5 develop

    strReleaseBranch = "release/" + new_tag
    repo.git.checkout('HEAD', b=strReleaseBranch)


    strArguments = strArguments.replace("{current_release}", strLatestTag)
    strArguments = strArguments.replace("{new_release}", new_tag)

    if blnVerbose:
        print(strCommand + " " + strArguments)
    
    if strFileName != 'none':
        # Generate CHANGELOG
        if strCommand != 'none':
            call([strCommand,strArguments])

        # Manual Change CHANGELOG
        if strEditor != 'none':
            EDITOR = os.environ.get('EDITOR',strEditor)
            f = open(strFileName, "r")
            call([EDITOR, f.name])

        # git add CHANGELOG
        repo.index.add(strFileName)

        # git commit -m "docs: update CHANGELOG"
        repo.index.commit(strFileCommitMessage)

    # git checkout master
    repo.git.checkout('master')

    # git merge --no-ff release/v0.0.4 -m 'Merge branch release/v0.0.4'
    strMessage= 'Merge branch release ' + strReleaseBranch
    repo.git.merge(strReleaseBranch, m=strMessage, no_ff=True)

    # git tag -a v0.0.5 -m v0.0.5
    repo.git.tag(m=new_tag, a=new_tag)

    # git push -u origin master
    repo.git.push('master', u='origin', tags=True)

    # git checkout develop
    repo.git.checkout('develop')

    strMessage= "Merge tag '" + new_tag + "' into develop"
    # git merge --no-ff master -m 'Merge tag 'v0.0.14' into develop'
    repo.git.merge('master', m=strMessage, no_ff=True)

    # git branch -d release/v0.0.6
    repo.git.branch(d=strReleaseBranch)

    # git push -u origin develop
    repo.git.push('develop', u='origin', tags=True)

    print("Release " + new_tag + " done.")

if __name__== "__main__":
   main()
